/** 
class Prompt
Prompts the play with a message and asks for input 

field keyPressed: Char - sets a value to which key has been pressed
field offsetX: int - sets offset for text print max value of 23
field offsetY: int - sets offset for text print max value of 64
static message: String - message to print on screen

setMessage(string newMessage) - setter for message
eraseLine() - erases the line according to the offset value 
promptUser() - prints the message to screen
*/

class Prompt {
    field Char keyCode;
    field int offsetX;
    field int offsetY;
    field String message;
    field PromptData promptData;
    field int promptWidth;

    constructor Prompt new(){
        let message = "empty message";
        let offsetY = 5;
        let offsetX = 8;
        let keyCode = 0;
        let promptWidth = 48;
        return this;
    }

    method void setMessage(String newMessage){
        let message = newMessage;
        return;
    }

    method void setOffset(int offsetX, int offsetY){
        let offsetX = offsetX;
        let offsetY = offsetY;
        return;
    }

    method void eraseLine() {
        var int count;
        var int characterLen;
        let count = 0;
        let characterLen = 64;

        while (count < characterLen){
            do Output.moveCursor(offsetY, count);
            let count = count + 1;
        }
        do Output.moveCursor(offsetY, offsetX);

        return;
    }

    method Array parseMessageToArray(){
        var Array parsedMessage;
        var String line;
        var int lineCount;
        // charCount is 0 to size of promptWidth
        var int charCount;
        var char currentChar;

        var int totalIndex;
        let lineCount = 0;
        let charCount = 0;

        let parsedMessage = Array.new(4);
        let line = String.new(promptWidth);

        do Output.moveCursor(0,0);
        do Output.printInt(message.length());

        // if the message is one line
        if(message.length() < promptWidth){
            let parsedMessage[0] = message;
            return parsedMessage;
        }

        let totalIndex = charCount + (promptWidth * lineCount);

        while(totalIndex < message.length()){
            let currentChar = message[totalIndex];
            let line[charCount] = currentChar;

            if(charCount = promptWidth){
                // do Output.moveCursor(offsetY + lineCount + 1, offsetX);
                // do Output.printString(line);
                let lineCount = lineCount + 1;
                let charCount = 0;
            } 
            else {
                let charCount = charCount + 1;
            }
            let totalIndex = totalIndex + 1;
        }


        return parsedMessage;
    }

    method PromptData promptUser(){
        var Boolean hasKeyBeenPressed;
        var int timeElapsed;
        var Array parsedMessage;
        var int messageLineCount;

        let hasKeyBeenPressed = false;
        let timeElapsed = 0;
        
        let keyCode = 0;
        
        // let parsedMessage = parseMessageToArray();
        // let messageLineCount = 0;

        do Output.moveCursor(offsetY + 6, offsetX);
        do Output.printString(message);
        
        // while(~(parsedMessage[messageLineCount] = null)){
        //     do Output.moveCursor(offsetY + messageLineCount, offsetX);
        //     do Output.printString(parsedMessage[0]);
        //     let messageLineCount = messageLineCount + 1;
        // }

        while(hasKeyBeenPressed = false){
            let keyCode = Keyboard.keyPressed();
            let timeElapsed = timeElapsed + 1;
            if(timeElapsed > 52){
                let timeElapsed = 0;
            }
            if(~(keyCode = 0)){
                let hasKeyBeenPressed = true;
            }
        }

        let promptData = PromptData.new(timeElapsed, keyCode);
        return promptData;
    }
    
    method void dispose() {
       do promptData.dispose();
       do Memory.deAlloc(this);
       return;
    }
}